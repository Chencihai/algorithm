## 数据库系统设计报告(python_mysql)

***\*1、概述\****            

本物流信息管理系统是一个综合性的管理平台，旨在提高物流操作的效率和准确性。系统通过用户权限管理、人员信息管理和订单信息管理等功能模块，实现了对物流过程中关键信息的高效处理和监控。本管理系统实现的功能大致可以概括为以下6种

1. 系统启动页面，包括登录入口；
2. 管理员登录和游客登录，验证用户身份并进入对应操作界面；
3. 管理员注册页面，允许新用户注册成为管理员；
4. 管理员信息选择操作页面，提供人员信息、订单信息等管理选项；
5. 人员信息操作页面，实现对收件人、寄件人和配送员信息的增删改查；
6. 订单信息操作页面，实现对订单信息的增删改查以及按条件查询。

***\*2、管理系统的权限\****

在本管理系统中，管理员有着如下的权限：

1、人员信息管理

①收件人信息操作：可以查看、添加、删除和修改收件人的详细信息，如姓名、地址等。

![image](https://github.com/Chencihai/algorithm/assets/95452629/90822d05-8e34-4d62-857c-306dd4cf9935)


②寄件人信息操作：可以对寄件人的相关信息进行管理，例如查看寄件人基本信息并进行相应的修改。

![image](https://github.com/Chencihai/algorithm/assets/95452629/3aff00b2-45bc-4bbb-8353-e8d021fada56)


③配送员信息操作：能够管理和更新配送员的个人信息，确保配送团队的信息准确无误。

![image](https://github.com/Chencihai/algorithm/assets/95452629/48386588-8688-4713-9a04-930e1c2e8a84)


2、订单信息管理

①查询功能：支持根据订单编号、收件人姓名、寄件人姓名或配送时间等多种条件进行订单查询。

②新增订单：允许录入新的订单信息，包括订单编号、运输时间、物流站、快递员、寄件人和收件人等信息。

③删除和更新订单：可删除或更新现有订单的信息，确保数据的准确性和及时性。

此外，管理员还可以通过系统的主页面选择不同的管理选项，进入对应的操作界面，执行详细的管理任务。这些功能都能够共同确保物流信息的高效管理和运营。

![image](https://github.com/Chencihai/algorithm/assets/95452629/cead6964-40ee-4042-ab95-47fb2b97d2fe)


***\*3\*******\*、\**** ***\*功能模块分析\****

系统前端的实现

系统前端的用户登录与权限管理部分的实现主要通过以下几个步骤：

1) 用户输入与验证：

在管理员登录页面，系统提供了用户名和密码输入框，用户需要输入正确的用户名和密码才能登录。

使用TKinker库中的StringVar()函数来存储用户的输入，并通过entry_username和entry_pwd变量获取用户输入的用户名和密码。

登录功能中，系统执行了SQL语句进行验证，例如"select * from manger where username='%s'"。如果查询结果不为空，则进一步比较输入的密码是否匹配，如果匹配成功，则允许用户进入系统后台。

 

2） 权限区分：

系统根据用户是普通用户还是管理员（即游客或管理员登录），提供不同的操作权限。

在主页面中，为普通用户和管理员分别设置了“管理员登录”和“游客登录”按钮，以区分不同用户的登录入口。

![image](https://github.com/Chencihai/algorithm/assets/95452629/cf58c3b4-45b3-447b-bd35-23af68496d99)


 

3）界面设计：

登录页面使用了Tkinter库创建窗口和各种控件如标签、按钮等。之所以使用Tkinter库来设计界面是因为Tkinter是Python的标准图形用户界面工具包，可以在所有主要的操作系统上运行，包括Windows、macOS和Linux。这意味着相同的代码，可以在不同的操作系统上无缝运行，极大地提高了软件的可移植性和适用范围。除此之外简单易用的接口、成本效益高、丰富的内置组件以及与Python语言的紧密结合等优点。这些特性使得Tkinter成为开发该系统的理想选择。

通过Label(root, text='账号：', font=("楷体", 15), bg='white').place(relx=0.4,rely=0.35)等代码设置界面布局，包括账号、密码输入框以及登录按钮的位置和样式。

Button(root, text="登录", ... fg='black', activebackground='black', activeforeground='white')用于创建并放置登录按钮。

![image](https://github.com/Chencihai/algorithm/assets/95452629/01aba305-a535-4acf-ad38-150f7517fffb)


4） 异常处理：

如果用户输入错误，系统会弹出提示信息，告知用户账号或密码错误。

使用showinfo(title='提示', message='账号/密码错误！')显示错误消息给用户。

![image](https://github.com/Chencihai/algorithm/assets/95452629/bdaf7904-942e-4c8f-a619-bfedaa9ecd66)


5）退出机制：

在每个页面的底部都设有“退出系统”按钮，点击后可以关闭当前页面并返回到系统的主页面。

Button(root, text="退出", command=root.destroy, ... fg='black', bg='gainsboro', activebackground='black', activeforeground='white')实现了这一功能。

![image](https://github.com/Chencihai/algorithm/assets/95452629/325d77f7-5cf9-4cfd-902b-a397f07708dc)


通过这样的设计，系统实现了一个基本的登录与权限管理功能，确保只有授权的用户才能访问特定的资源或执行特定的操作。

***\*4、技术实现分析\****

系统后端的实现

系统后端使用了Python的pymysql库来连接MySQL数据库，并通过SQL语句执行各种数据操作。pymysql是一个纯Python写的MySQL客户端库，它提供了对MySQL数据库的原生支持，包括连接管理、游标操作、事务处理和错误处理等功能。由于其简单性和效率，pymysql被广泛应用于需要高性能数据库访问的应用程序中。使用pymysql进行数据库操作的基本步骤涉及建立到数据库服务器的连接、创建游标对象来执行SQL语句、提交或回滚事务以及最后关闭连接。pymysql还支持多种参数配置，如连接超时设置、查询缓存等，以适应不同的开发需求。而本数据库使用起的原因在于它提供了丰富的功能来执行SQL语句、管理数据库连接等，适合处理复杂的数据库操作需求。能够提供高效的数据传输和处理能力，这对于需要频繁访问数据库的物流信息管理系统尤为重要。pymysql的使用相对简单直观，它的API设计清晰，便于理解和实现各种数据库操作。

首先建立与数据库的链接。所需的变量有：主机名或者IP地址、用户名、密码、数据库名称以及端口号。

![image](https://github.com/Chencihai/algorithm/assets/95452629/301d6ecc-ed9c-4185-a1c8-da167c129516)


接下来实现对MySQL数据库的查询、插入、更新和删除等操作，并且能够接受和处理这些操作的结果。通过调用pymysql库中的cursor()方法创建一个游标对象，通过这个游标对象来执行所有的SQL语句并获取结果。

完成对数据库基本操作的实现后开始实现“指定SQL语句的执行”以便来查询或者更新数据库中的数据。例如，在验证管理员登录时执行了查询管理员信息的SQL语句。

![image](https://github.com/Chencihai/algorithm/assets/95452629/0634e5dc-eda0-40b3-93ce-f6c49cbabdab)


在已经完成了数据库的增删改查后最重要的莫过于将更改后的数据保存在数据库中。通过db.commit()完成。

最后完成游标和数据库链接的关闭，释放资源。

***\*5、数据库分析\****

数据库的设计遵循模块化原则，每个模块对应系统中不同的实体或概念。例如，收件人、寄件人和配送员作为物流系统的关键参与者，各自拥有独立的信息表。这种设计便于管理和扩展，也有助于保持数据的一致性和完整性。
![image](https://github.com/Chencihai/algorithm/assets/95452629/0abc4ebc-ee9b-4278-8347-0c61ea06800c)


通过创建多个表来存储不同类型的数据，并确保每张表都满足第三范式（3NF），减少了数据冗余，提高了数据完整性和查询效率。例如，使用单独的表来存储收件人、寄件人和配送员的信息，而不是在一个表中混合这些信息。

 
![image](https://github.com/Chencihai/algorithm/assets/95452629/01d3622b-b248-4008-bb46-4460225d4308)


通过以上代码创建收件人表。

Rname：VARCHAR(100) 类型，表示这是一个可变长字符串字段，最大长度为100个字符。使用CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci指定了字符集和排序规则，意味着这个字段可以存储任何Unicode字符，并且按照通用顺序进行排序。NOT NULL表明这个字段必须有值，不可以为空。

RID：VARCHAR(100) 类型，同样是一个可变长字符串字段，最大长度为100个字符。它被指定为PRIMARY KEY，这意味着这个字段将作为主键使用。主键是表中唯一标识每条记录的字段或字段组合，确保数据的唯一性和完整性。

Raddress：VARCHAR(255) 类型，也是一个可变长字符串字段，最大长度为255个字符。这个字段用来存储收件人的地址信息。

Rsex：VARCHAR(10) 类型，又一个可变长字符串字段，最大长度为10个字符。这里存储的是收件人的性别信息，可能用于进一步的数据分析或统计。

Rphonenumber：VARCHAR(20) 类型，最长20个字符的可变长字符串字段。此字段用于存储收件人的电话号码信息。

| 收件人(recipient) |                    |              |      |             |
| ----------------- | ------------------ | ------------ | ---- | ----------- |
| Rname             | RID                | Raddress     | Rsex | Rphone      |
| 张三              | 123456789012345678   | 北京大学   | 男   | 12345678901 |

 
![image](https://github.com/Chencihai/algorithm/assets/95452629/93336283-331f-421f-bf6c-c57923b6b388)


通过以上代码创建寄件人表。

Sname：VARCHAR(100) 类型，表示这是一个可变长字符串字段，最大长度为100个字符。使用CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci指定了字符集和排序规则，意味着这个字段可以存储任何Unicode字符，并且按照通用顺序进行排序。NOT NULL表明这个字段必须有值，不可以为空。

SID：VARCHAR(100) 类型，同样是一个可变长字符串字段，最大长度为100个字符。它被指定为PRIMARY KEY，这意味着这个字段将作为主键使用。主键是表中唯一标识每条记录的字段或字段组合，确保数据的唯一性和完整性。

Saddress：VARCHAR(255) 类型，也是一个可变长字符串字段，最大长度为255个字符。这个字段用来存储寄件人的地址信息。

Ssex：VARCHAR(10) 类型，又一个可变长字符串字段，最大长度为10个字符。这里存储的是寄件人的性别信息，可能用于进一步的数据分析或统计。

Sphonenumber：VARCHAR(20) 类型，最长20个字符的可变长字符串字段。此字段用于存储寄件人的电话号码信息。

| 寄件人(sender) |                    |              |      |             |
| -------------- | ------------------ | ------------ | ---- | ----------- |
| Sname          | SID                | Saddress     | Ssex | Sphone      |
| 张三          | 123456789012345678 | 北京大学 | 男   | 12345678901 |

![image](https://github.com/Chencihai/algorithm/assets/95452629/797b901c-7e25-4faf-ae48-84cc1c0277f7)


上述代码创建了配送员表

Dname：VARCHAR(100) 类型，表示这是一个可变长字符串字段，最大长度为100个字符。使用CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci指定了字符集和排序规则，意味着这个字段可以存储任何Unicode字符，并且按照通用顺序进行排序。NOT NULL表明这个字段必须有值，不可以为空。

Dnum：VARCHAR(100) 类型，同样是一个可变长字符串字段，最大长度为100个字符。它被指定为PRIMARY KEY，这意味着这个字段将作为主键使用。主键是表中唯一标识每条记录的字段或字段组合，确保数据的唯一性和完整性。

DID：VARCHAR(100) 类型，又一个可变长字符串字段，最大长度为100个字符。此字段可能用于配送员的某种内部编号或标识码。

Dsex：VARCHAR(10) 类型，是一个可变长字符串字段，最大长度为10个字符。这里存储的是配送员的性别信息，可能用于进一步的数据分析或统计。

Dphonenumber：VARCHAR(20) 类型，最长20个字符的可变长字符串字段。此字段用于存储配送员的电话号码信息。

| 配送员(distributor) |                    |      |      |             |
| ------------------- | ------------------ | ---- | ---- | ----------- |
| Dname               | Dnum               | DID  | Dsex | Dphone      |
| 张三               | 123456789012345678 | 123  | 男   | 12345678901 |

 

![image](https://github.com/Chencihai/algorithm/assets/95452629/7372b9ce-2d63-4666-9376-aafba13fc63c)

 

上述代码创建了订单表

Onum：VARCHAR(20) 类型，表示这是一个可变长字符串字段，最大长度为20个字符。作为NOT NULL PRIMARY KEY，这个字段将被用作主键，确保每条订单记录的唯一性。

Odelivery_time：DATETIME 类型，表示这是一个日期时间类型的字段。它被设置为默认值 '2023-01-01 00:00:00'，意味着当创建新订单时，如果未指定此字段的值，将使用这个默认日期和时间。

Olog_station：VARCHAR(50) 类型，表示这是一个可变长字符串字段，最大长度为50个字符。这个字段可能用来记录订单处理的物流站信息。

Odistributor：VARCHAR(50) 类型，同样是一个可变长字符串字段，最大长度为50个字符。此字段用来存储负责配送订单的配送员信息。

Osender：VARCHAR(50) 类型，另一个可变长字符串字段，最大长度为50个字符。这里存储的是寄件人的信息。

Orecipient：VARCHAR(50) 类型，最长50个字符的可变长字符串字段。此字段用于存储收件人的信息。

Ogoods：VARCHAR(50) 类型，也是一个可变长字符串字段，最大长度为50个字符。这个字段用来记录订单中的商品信息。

Oprice：DECIMAL(10, 2) 类型，表示这是一个定点数类型字段，总共有12位数字宽度（其中小数点后有两位），可以存储具有货币价值的数值数据。这个字段用于存储订单的价格信息。

| 订单(orders) |       |          |        |         |        |          |        |
| ------------ | ----- | -------- | ------ | ------- | ------ | -------- | ------ |
| Onum         | Otime | Ostation | Odist  | Osender | Orecpt | Ogoods   | Oprice |
| 订单号       | 时间  | 站点名   | 配送员 | 寄件人  | 收件人 | 商品描述 | 价格   |

 

通过创建多个表来存储不同类型的数据，并确保每张表都满足第三范式（3NF），减少了数据冗余，提高了数据完整性和查询效率。例如，使用单独的表来存储收件人、寄件人和配送员的信息，而不是在一个表中混合这些信息。

对于经常需要查询的字段设置索引，比如在订单表中的运输时间(Odelivery_time)、物流站(Olog_station)等字段，可以加快查询速度。虽然文档中没有直接展示索引创建的语句，但在实际开发中通常会包含这样的操作。

管理员表(manger)的存在为系统提供了访问控制机制，通过用户名和密码验证用户身份。这保证了只有授权的用户才能操作系统功能，增强了系统的安全性。

进行数据的完整性约束，在插入数据时使用了INSERT IGNORE INTO语句来忽略重复值，避免了因为尝试插入重复记录而引起的错误。这对于维护数据库的一致性非常有帮助。同时，还利用了ON DUPLICATE KEY UPDATE来处理主键冲突的情况，自动更新重复键对应的列值。

通过使用INSERT IGNORE INTO语句来进行数据的完整性约束，在插入数据时忽略重复值，避免因尝试插入重复记录而引起的错误。例如，向收件人(recipient)、寄件人(sender)和配送员(distributor)表中插入初始数据时使用了此语句。

![image](https://github.com/Chencihai/algorithm/assets/95452629/0b7a5e5b-c544-42bb-af09-e65c3b059646)


ON DUPLICATE KEY UPDATE是MySQL提供的一种特殊更新语句，用于在尝试插入记录时如果遇到主键或唯一约束冲突（即已存在相同的主键值），则自动更新现有记录的相应字段值。

这个语句通常与INSERT ... ON DUPLICATE KEY UPDATE结构一起使用，允许在遇到重复键值时执行更新操作。当插入操作失败（因为违反了唯一性约束），系统不会抛出错误，而是会执行UPDATE部分的语句。这样，即使有重复键值的情况发生，也可以保证数据库中的数据一致性，并保留最新的数据版本。

利用ON DUPLICATE KEY UPDATE机制处理主键冲突的情况。当插入新记录时，如果遇到已存在的主键值（例如订单编号），则自动更新现有记录的相应列值。这在订单表(orders)中的数据插入示例中得到应用，确保了订单信息的一致性与唯一性。

![image](https://github.com/Chencihai/algorithm/assets/95452629/3116b576-5085-440c-8c9e-2e8a84bc2f98)

此外通过在订单表中设置外键将四个表完整的联系了起来，这些外键分别引用了以下三个表的主键或候选键：

sender 表的 Sname 字段，确保每个订单都有一个有效的寄件人。

recipient 表的 Rname 字段，确保每个订单都有一个有效的收件人。

distributor 表的 Dname 字段，确保每个订单都有一个有效的配送员。

通过设置这些外键约束，可以保持数据的一致性和完整性，同时防止在订单与相关实体之间存在不匹配的情况。

 

***\*6、总结\****

 

设计数据库需要根据目标需求理清所需处理的各项数据之间的关系和逻辑，只有在搞清了这些关系的基础上才能画出ER图，进而将概念模型转化为逻辑模型。也就是定义成表并添加约束条件。最后将其实现，并添加UI设计制作成一个可用的系统。

在设计的过程中也会遇到各种各样的问题：组内沟通上的问题提出设计需求者可能无法向设计实现者准确传达要求定义导致设计出的数据库无法完成某些功能、数据可能无法满足各类约束条件、主键外键设计不合理等一系列问题。这些可能非常简单的问题产生的原因多半在于着手进行实现前的准备工作。例如在本系统实现的过程中一度忘记进行外键的约束，导致设计在实现后有着许多的问题，比如能够插入不应该存在的信息，记录等。这一问题在事后解决的过程中面临着更多的问题，这些问题往往是牵一发而动全身，想要修改一个小小的问题可最后的工作量丝毫不亚于重新设计一个数据库管理系统了。因此在进行数据库系统的设计与实现时一定要特别注意在实现之前要彻底搞清楚设计要求，确保所有数据都遵循相同的规则和约束，如参照完整性、实体完整性等。这样才能保证设计出的数据库系统复合设计预期。

 

本设计实现了一个物流信息的数据库管理系统，管理范围涉及到了寄件人，收件人，派送员三部分。但仍然有可以改进的地方。比如一个真正好的物流管理系统还应该包含库存管理，运输管理，仓库管理，供应链协同管理等。由于本小组成员水平有限想要在短时间内设计实现出一个完善的数据库系统实在太过困难，还望海涵。

另外本设计在数据备份、系统拓展性、性能优化等问题上没有做过多的投入，也是能够进行改进的点
